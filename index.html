<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hand Movement Synchronization Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.js"></script>
    <!-- Add DTW library for movement analysis -->
    <script src="https://cdn.jsdelivr.net/npm/dtw@3.4.0/dist/dtw.min.js"></script>
    <!-- Add CCA implementation -->
    <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.10.4/dist/ml-matrix.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
            background-color: #f0f0f0;
        }
        
        #video-container {
            display: flex;
            flex: 1;
            width: 100%;
            background-color: #ffffff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        
        .video-wrapper {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            position: relative;
            border: 2px solid transparent;
            overflow: hidden;
        }
    
        .video-wrapper.active {
            border-color: #4CAF50;
        }

        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #localVideo {
            transform: scaleX(-1);
        }
        
        #outputCanvas, #remoteCanvas {
            z-index: 1;
            pointer-events: none;
        }

        #outputCanvas {
            transform: scaleX(-1);
        }

        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            padding: 15px;
            background-color: #333;
            gap: 15px;
        }

        #synchronization-metrics {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            z-index: 2;
        }
    
        .control-button {
            padding: 10px 20px;
            background-color: #4CAF50;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            color: white;
            transition: background-color 0.3s;
        }
    
        .control-button:hover {
            background-color: #45a049;
        }

        .metric {
            margin: 5px 0;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="synchronization-metrics">
        <div class="metric" id="dtw-score">DTW Score: --</div>
        <div class="metric" id="cca-score">CCA Score: --</div>
        <div class="metric" id="correlation-score">Cross-Correlation: --</div>
        <div class="metric" id="overall-sync">Overall Synchronization: --</div>
    </div>

    <div id="video-container">
        <div class="video-wrapper" id="localVideo-wrapper">
            <video id="localVideo" autoplay playsinline muted></video>
            <canvas id="outputCanvas"></canvas>
        </div>
        <div class="video-wrapper" id="remoteVideo-wrapper">
            <video id="remoteVideo" autoplay playsinline></video>
            <canvas id="remoteCanvas"></canvas>
        </div>
    </div>

    <div id="controls">
        <button class="control-button" id="muteButton">Mute</button>
        <button class="control-button" id="cameraButton">Turn Off Camera</button>
        <button class="control-button" id="startAnalysis">Start Analysis</button>
        <button class="control-button" id="downloadData">Download Data</button>
    </div>
    
    <script>
        // Hand tracking initialization and core variables
        let localHandData = [];
        let remoteHandData = [];
        const ANALYSIS_WINDOW = 60; // 60 frames for analysis
        let isAnalysisActive = false;

        // Initialize hands detection for both local and remote video
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        // Synchronization analysis functions
        function calculateDTW(seq1, seq2) {
            if (!seq1.length || !seq2.length) return 0;
            const dtw = new DTW();
            const distance = dtw.compute(seq1, seq2);
            // Normalize the distance
            return 1 / (1 + distance);
        }

        function calculateCCA(X, Y) {
            if (!X.length || !Y.length) return 0;
            
            // Convert arrays to matrices
            const matX = new ML.Matrix(X);
            const matY = new ML.Matrix(Y);
            
            // Center the data
            const meanX = matX.mean('column');
            const meanY = matY.mean('column');
            
            const centeredX = matX.subRowVector(meanX);
            const centeredY = matY.subRowVector(meanY);
            
            // Calculate correlation matrix
            const corr = centeredX.transpose().mmul(centeredY);
            const eigenvalues = corr.eig().realEigenvalues;
            
            // Return the maximum correlation
            return Math.max(...eigenvalues);
        }

        function calculateCrossCorrelation(seq1, seq2) {
            if (!seq1.length || !seq2.length) return 0;
            
            let sum = 0;
            const n = Math.min(seq1.length, seq2.length);
            
            for (let i = 0; i < n; i++) {
                sum += seq1[i] * seq2[i];
            }
            
            return sum / n;
        }

        // Analysis update function
        function updateSynchronizationMetrics() {
            if (!isAnalysisActive || localHandData.length < ANALYSIS_WINDOW || remoteHandData.length < ANALYSIS_WINDOW) return;

            // Get the latest window of data
            const localWindow = localHandData.slice(-ANALYSIS_WINDOW);
            const remoteWindow = remoteHandData.slice(-ANALYSIS_WINDOW);

            // Calculate metrics
            const dtwScore = calculateDTW(localWindow, remoteWindow);
            const ccaScore = calculateCCA(localWindow, remoteWindow);
            const corrScore = calculateCrossCorrelation(localWindow, remoteWindow);

            // Calculate overall synchronization (weighted average as per paper)
            const overallSync = (dtwScore + ccaScore + corrScore) / 3;

            // Update UI
            document.getElementById('dtw-score').textContent = `DTW Score: ${dtwScore.toFixed(3)}`;
            document.getElementById('cca-score').textContent = `CCA Score: ${ccaScore.toFixed(3)}`;
            document.getElementById('correlation-score').textContent = `Cross-Correlation: ${corrScore.toFixed(3)}`;
            document.getElementById('overall-sync').textContent = `Overall Synchronization: ${overallSync.toFixed(3)}`;
        }

        // Modified onResults to include synchronization analysis
        function onResults(results) {
            if (!results.multiHandLandmarks) return;

            const handData = results.multiHandLandmarks.map(landmarks => 
                landmarks.map(l => ({x: l.x, y: l.y, z: l.z}))
            );

            // Store hand data for analysis
            if (results.image === localVideo) {
                localHandData.push(handData);
                if (localHandData.length > ANALYSIS_WINDOW * 2) {
                    localHandData = localHandData.slice(-ANALYSIS_WINDOW);
                }
            } else {
                remoteHandData.push(handData);
                if (remoteHandData.length > ANALYSIS_WINDOW * 2) {
                    remoteHandData = remoteHandData.slice(-ANALYSIS_WINDOW);
                }
            }

            // Draw landmarks
            const canvas = results.image === localVideo ? outputCanvas : remoteCanvas;
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

            results.multiHandLandmarks.forEach(landmarks => {
                drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 3});
                drawLandmarks(ctx, landmarks, {color: '#FF0000', radius: 2});
            });

            if (isAnalysisActive) {
                updateSynchronizationMetrics();
            }
        }

        // Initialize video streams and WebRTC
        // [Previous WebRTC initialization code remains the same]

        // Add event listeners for new controls
        document.getElementById('startAnalysis').addEventListener('click', () => {
            isAnalysisActive = !isAnalysisActive;
            document.getElementById('startAnalysis').textContent = 
                isAnalysisActive ? 'Stop Analysis' : 'Start Analysis';
        });

        document.getElementById('downloadData').addEventListener('click', () => {
            const data = {
                local: localHandData,
                remote: remoteHandData,
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'hand-sync-data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
        // Function to start video stream and initialize hand tracking
        async function startVideo(videoElement) {
            try {
                // Get user media stream
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true,
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
        
                // Set up video element
                videoElement.srcObject = stream;
                localStream = stream;
        
                // Wait for video metadata to load
                await new Promise(resolve => {
                    videoElement.onloadedmetadata = () => {
                        resolve();
                    };
                });
        
                // Start video playback
                await videoElement.play();
        
                // Set up canvas dimensions
                const outputCanvas = document.getElementById('outputCanvas');
                const remoteCanvas = document.getElementById('remoteCanvas');
                outputCanvas.width = videoElement.videoWidth;
                outputCanvas.height = videoElement.videoHeight;
                remoteCanvas.width = videoElement.videoWidth;
                remoteCanvas.height = videoElement.videoHeight;
        
                // Initialize hand tracking
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: videoElement });
                    },
                    width: 1280,
                    height: 720
                });
                camera.start();
        
                // Set up WebRTC connection
                setupPeerConnection();
        
                // Update status
                updateStatus('Video stream started');
            
            } catch (error) {
                console.error('Error starting video:', error);
                updateStatus('Failed to start video: ' + error.message);
            }
        }

        // Helper function to update status
        function updateStatus(message) {
            console.log(message);
        // Start the application
        startVideo(localVideo);
    </script>
</body>
</html>
