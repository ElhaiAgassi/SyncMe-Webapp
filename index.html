<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hand Movement Synchronization Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.js"></script>
    <!-- Add DTW library for movement analysis -->
    <script src="https://cdn.jsdelivr.net/npm/dtw@3.4.0/dist/dtw.min.js"></script>
    <!-- Add CCA implementation -->
    <script src="https://cdn.jsdelivr.net/npm/ml-matrix@6.10.4/dist/ml-matrix.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
            background-color: #f0f0f0;
        }
        
        #video-container {
            display: flex;
            flex: 1;
            width: 100%;
            background-color: #ffffff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        
        .video-wrapper {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            position: relative;
            border: 2px solid transparent;
            overflow: hidden;
        }
    
        .video-wrapper.active {
            border-color: #4CAF50;
        }

        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #localVideo {
            transform: scaleX(-1);
        }
        
        #outputCanvas, #remoteCanvas {
            z-index: 1;
            pointer-events: none;
        }

        #outputCanvas {
            transform: scaleX(-1);
        }

        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            padding: 15px;
            background-color: #333;
            gap: 15px;
        }

        #synchronization-metrics {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            z-index: 2;
        }
    
        .control-button {
            padding: 10px 20px;
            background-color: #4CAF50;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            color: white;
            transition: background-color 0.3s;
        }
    
        .control-button:hover {
            background-color: #45a049;
        }

        .metric {
            margin: 5px 0;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="synchronization-metrics">
        <div class="metric" id="dtw-score">DTW Score: --</div>
        <div class="metric" id="cca-score">CCA Score: --</div>
        <div class="metric" id="correlation-score">Cross-Correlation: --</div>
        <div class="metric" id="overall-sync">Overall Synchronization: --</div>
    </div>

    <div id="video-container">
        <div class="video-wrapper" id="localVideo-wrapper">
            <video id="localVideo" autoplay playsinline muted></video>
            <canvas id="outputCanvas"></canvas>
        </div>
        <div class="video-wrapper" id="remoteVideo-wrapper">
            <video id="remoteVideo" autoplay playsinline></video>
            <canvas id="remoteCanvas"></canvas>
        </div>
    </div>

    <div id="controls">
        <button class="control-button" id="muteButton">Mute</button>
        <button class="control-button" id="cameraButton">Turn Off Camera</button>
        <button class="control-button" id="startAnalysis">Start Analysis</button>
        <button class="control-button" id="downloadData">Download Data</button>
    </div>
    
    <script>
        // Hand tracking initialization and core variables
        let localHandData = [];
        let remoteHandData = [];
        const ANALYSIS_WINDOW = 60; // 60 frames for analysis
        let isAnalysisActive = false;
        const socket = io({
            transports: ['websocket'],
            reconnectionAttempts: 5,
            reconnectionDelay: 1000
        });
        // Initialize hands detection for both local and remote video
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.5
        });

        // Synchronization analysis functions
        function calculateDTW(seq1, seq2) {
            if (!seq1.length || !seq2.length) return 0;
            const dtw = new DTW();
            const distance = dtw.compute(seq1, seq2);
            // Normalize the distance
            return 1 / (1 + distance);
        }

        function calculateCCA(X, Y) {
            if (!X.length || !Y.length) return 0;
            
            // Convert arrays to matrices
            const matX = new ML.Matrix(X);
            const matY = new ML.Matrix(Y);
            
            // Center the data
            const meanX = matX.mean('column');
            const meanY = matY.mean('column');
            
            const centeredX = matX.subRowVector(meanX);
            const centeredY = matY.subRowVector(meanY);
            
            // Calculate correlation matrix
            const corr = centeredX.transpose().mmul(centeredY);
            const eigenvalues = corr.eig().realEigenvalues;
            
            // Return the maximum correlation
            return Math.max(...eigenvalues);
        }

        function calculateCrossCorrelation(seq1, seq2) {
            if (!seq1.length || !seq2.length) return 0;
            
            let sum = 0;
            const n = Math.min(seq1.length, seq2.length);
            
            for (let i = 0; i < n; i++) {
                sum += seq1[i] * seq2[i];
            }
            
            return sum / n;
        }

        function calculateSynchronization(localHand, remoteHand) {
            if (!localHand || !remoteHand) return;
        
            // Convert data for algorithms
            const localSeq = localHand.map(l => [l.x, l.y, l.z]);
            const remoteSeq = remoteHand.map(l => [l.x, l.y, l.z]);
        
            try {
                // Calculate metrics
                const dtwScore = calculateDTW(localSeq, remoteSeq);
                const ccaScore = calculateCCA(localSeq, remoteSeq);
                const corrScore = calculateCrossCorrelation(
                    localHand.map(l => l.x),
                    remoteHand.map(l => l.x)
                );
        
                // Update display with percentages
                document.getElementById('dtw-score').textContent = 
                    `DTW Score: ${(dtwScore * 100).toFixed(1)}%`;
                document.getElementById('cca-score').textContent = 
                    `CCA Score: ${(ccaScore * 100).toFixed(1)}%`;
                document.getElementById('correlation-score').textContent = 
                    `Cross-Correlation: ${(corrScore * 100).toFixed(1)}%`;
                
                const overallSync = (dtwScore + ccaScore + corrScore) / 3;
                document.getElementById('overall-sync').textContent = 
                    `Overall Synchronization: ${(overallSync * 100).toFixed(1)}%`;
        
            } catch (error) {
                console.error('Error calculating synchronization:', error);
            }
        }

        // Analysis update function
        function updateSynchronizationMetrics() {
            if (!isAnalysisActive || localHandData.length < ANALYSIS_WINDOW || remoteHandData.length < ANALYSIS_WINDOW) return;

            // Get the latest window of data
            const localWindow = localHandData.slice(-ANALYSIS_WINDOW);
            const remoteWindow = remoteHandData.slice(-ANALYSIS_WINDOW);

            // Calculate metrics
            const dtwScore = calculateDTW(localWindow, remoteWindow);
            const ccaScore = calculateCCA(localWindow, remoteWindow);
            const corrScore = calculateCrossCorrelation(localWindow, remoteWindow);

            // Calculate overall synchronization (weighted average as per paper)
            const overallSync = (dtwScore + ccaScore + corrScore) / 3;

            // Update UI
            document.getElementById('dtw-score').textContent = `DTW Score: ${dtwScore.toFixed(3)}`;
            document.getElementById('cca-score').textContent = `CCA Score: ${ccaScore.toFixed(3)}`;
            document.getElementById('correlation-score').textContent = `Cross-Correlation: ${corrScore.toFixed(3)}`;
            document.getElementById('overall-sync').textContent = `Overall Synchronization: ${overallSync.toFixed(3)}`;
        }

       function onResults(results) {
            const canvasElement = document.getElementById('outputCanvas');
            const canvasCtx = canvasElement.getContext('2d');
            
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // Draw video frame first
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        
            let handData = [];
        
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    // Store hand data
                    handData.push(landmarks.map(l => ({
                        x: l.x * canvasElement.width,
                        y: l.y * canvasElement.height,
                        z: l.z
                    })));
        
                    // Draw hand connections
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {
                        color: '#00FF00',
                        lineWidth: 5
                    });
                    
                    // Draw hand landmarks
                    drawLandmarks(canvasCtx, landmarks, {
                        color: '#FF0000',
                        lineWidth: 3,
                        radius: 7,
                        fillColor: '#FFFFFF'
                    });
                }
        
                // Store data based on video source
                if (results.image === localVideo) {
                    localHandData = handData;
                } else {
                    remoteHandData = handData;
                }
        
                // Update synchronization metrics if analysis is active
                if (isAnalysisActive && localHandData.length > 0 && remoteHandData.length > 0) {
                    calculateSynchronization(localHandData[0], remoteHandData[0]);
                }
            }
            
            canvasCtx.restore();
        }

        // Initialize video streams and WebRTC
        // [Previous WebRTC initialization code remains the same]

        // Add event listeners for new controls
        document.getElementById('startAnalysis').addEventListener('click', () => {
            isAnalysisActive = !isAnalysisActive;
            const button = document.getElementById('startAnalysis');
            button.textContent = isAnalysisActive ? 'Stop Analysis' : 'Start Analysis';
            button.style.backgroundColor = isAnalysisActive ? '#ff4444' : '#4CAF50';
        });

        document.getElementById('downloadData').addEventListener('click', () => {
            const data = {
                local: localHandData,
                remote: remoteHandData,
                timestamp: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'hand-sync-data.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
        // Function to start video stream and initialize hand tracking
        async function startVideo(videoElement) {
            try {
                // Get user media stream
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true,
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
        
                // Set up video element
                videoElement.srcObject = stream;
                localStream = stream;
        
                // Wait for video metadata to load
                await new Promise(resolve => {
                    videoElement.onloadedmetadata = () => {
                        resolve();
                    };
                });
        
                // Start video playback
                await videoElement.play();
        
                // Set up canvas dimensions
                const outputCanvas = document.getElementById('outputCanvas');
                const remoteCanvas = document.getElementById('remoteCanvas');
                outputCanvas.width = videoElement.videoWidth;
                outputCanvas.height = videoElement.videoHeight;
                remoteCanvas.width = videoElement.videoWidth;
                remoteCanvas.height = videoElement.videoHeight;
        
                // Initialize hand tracking
                const camera = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({ image: videoElement });
                    },
                    width: 1280,
                    height: 720
                });
                camera.start();
        
                // Set up WebRTC connection
                setupPeerConnection();
        
                // Update status
                updateStatus('Video stream started');
            
            } catch (error) {
                console.error('Error starting video:', error);
                updateStatus('Failed to start video: ' + error.message);
            }
        }
                
        // Helper function to update status
        function updateStatus(message) {
            console.log(message);
        }
        // WebRTC configuration
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ],
            iceTransportPolicy: 'all',
            iceCandidatePoolSize: 10,
            bundlePolicy: 'max-bundle',
            rtcpMuxPolicy: 'require',
            sdpSemantics: 'unified-plan'
        };
        
        let peerConnection;
        let localStream;
        let dataChannel;
        
        async function setupPeerConnection() {
            try {
                // Create new RTCPeerConnection
                peerConnection = new RTCPeerConnection(configuration);
                
                // Add local media tracks to peer connection
                if (localStream) {
                    localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, localStream);
                    });
                }
        
                // Create data channel for hand tracking data
                dataChannel = peerConnection.createDataChannel('handData', {
                    ordered: true,
                    maxRetransmits: 3
                });
        
                // Set up data channel event handlers
                setupDataChannelHandlers();
        
                // Handle incoming remote tracks
                peerConnection.ontrack = handleRemoteTrack;
        
                // Handle ICE candidates
                peerConnection.onicecandidate = event => {
                    if (event.candidate) {
                        socket.emit('ice-candidate', { candidate: event.candidate });
                    }
                };
        
                // Handle connection state changes
                peerConnection.onconnectionstatechange = () => {
                    updateStatus(`WebRTC connection state: ${peerConnection.connectionState}`);
                    if (peerConnection.connectionState === 'connected') {
                        setupBitrateHandling();
                    }
                };
        
                // Handle ICE connection state changes
                peerConnection.oniceconnectionstatechange = () => {
                    updateStatus(`ICE connection state: ${peerConnection.iceConnectionState}`);
                };
        
                // Handle signaling state changes
                peerConnection.onsignalingstatechange = () => {
                    updateStatus(`Signaling state: ${peerConnection.signalingState}`);
                };
        
                // Create and send offer if we're the initiator
                if (!document.location.hash) {
                    await createAndSendOffer();
                }
        
                updateStatus('WebRTC connection setup complete');
        
                } catch (error) {
                    console.error('Error setting up WebRTC:', error);
                    updateStatus('Failed to setup WebRTC: ' + error.message);
                }
            }
        
            function setupDataChannelHandlers() {
                dataChannel.onopen = () => {
                    updateStatus('Data channel opened');
                };
            
                dataChannel.onclose = () => {
                    updateStatus('Data channel closed');
                };
            
                dataChannel.onmessage = event => {
                    // Handle incoming hand tracking data
                    const handData = JSON.parse(event.data);
                    remoteHandData = handData;
                    updateSynchronizationMetrics();
                };
            }
            
            function handleRemoteTrack(event) {
                const remoteVideo = document.getElementById('remoteVideo');
                if (!remoteVideo.srcObject) {
                    remoteVideo.srcObject = new MediaStream();
                }
                remoteVideo.srcObject.addTrack(event.track);
            }
            
            function setupBitrateHandling() {
                // Set video bitrate to ensure smooth transmission
                peerConnection.getSenders().forEach(sender => {
                    if (sender.track && sender.track.kind === 'video') {
                        const parameters = sender.getParameters();
                        if (!parameters.encodings) {
                            parameters.encodings = [{}];
                        }
                        parameters.encodings[0].maxBitrate = 1000000; // 1 Mbps
                        sender.setParameters(parameters)
                            .catch(e => console.error('Error setting bitrate:', e));
                    }
                });
            }
            
            async function createAndSendOffer() {
                try {
                    const offer = await peerConnection.createOffer({
                        offerToReceiveAudio: true,
                        offerToReceiveVideo: true
                    });
                    
                    await peerConnection.setLocalDescription(offer);
                    
                    // Send the offer through signaling server
                    socket.emit('offer', { offer: peerConnection.localDescription });
                    updateStatus('Offer sent');
                } catch (error) {
                    console.error('Error creating offer:', error);
                    updateStatus('Failed to create offer: ' + error.message);
                }
            }
            
            // Socket.io event handlers
            socket.on('offer', async data => {
                try {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    socket.emit('answer', { answer });
                    updateStatus('Answered incoming call');
                } catch (error) {
                    console.error('Error handling offer:', error);
                    updateStatus('Failed to handle offer: ' + error.message);
                }
            });
            
            socket.on('answer', async data => {
                try {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                    updateStatus('Connected to peer');
                } catch (error) {
                    console.error('Error handling answer:', error);
                    updateStatus('Failed to handle answer: ' + error.message);
                }
            });
            
            socket.on('ice-candidate', async data => {
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                } catch (error) {
                    console.error('Error adding ICE candidate:', error);
                    updateStatus('Failed to add ICE candidate: ' + error.message);
                }
            });
        // Start the application
        startVideo(localVideo);
    </script>
</body>
</html>
